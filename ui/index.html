<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>sentinel-ebpf debug</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.3/Sortable.min.js"></script>
    <style>
      :root {
        --mono: "SF Mono", "Consolas", "Liberation Mono", Menlo, monospace;
        --bg: #0f1419;
        --bg-card: #1a2332;
        --border: #2d3a4f;
        --text: #e6edf3;
        --text-muted: #8b949e;
        --accent: #58a6ff;
        --accent-dim: #388bfd66;
        --pre-bg: #161b22;
        --success: #3fb950;
        --error: #f85149;
      }
      [data-theme="light"] {
        --bg: #f0f2f5;
        --bg-card: #ffffff;
        --border: #d0d7de;
        --text: #1f2328;
        --text-muted: #656d76;
        --accent: #0969da;
        --accent-dim: #0969da22;
        --pre-bg: #f6f8fa;
      }
      * { box-sizing: border-box; }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
        background: var(--bg);
        color: var(--text);
        margin: 0;
        padding: 24px;
        line-height: 1.5;
        min-height: 100vh;
      }
      .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 12px;
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 1px solid var(--border);
      }
      .header h1 {
        margin: 0;
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--text);
        letter-spacing: -0.02em;
      }
      .header .subtitle {
        color: var(--text-muted);
        font-size: 0.875rem;
      }
      .toggle-wrap {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .toggle-btn {
        background: var(--bg-card);
        color: var(--text);
        border: 1px solid var(--border);
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 0.8125rem;
        cursor: pointer;
        transition: background 0.15s, border-color 0.15s;
      }
      .toggle-btn:hover {
        background: var(--border);
      }
      .section {
        background: var(--bg-card);
        border: 1px solid var(--border);
        border-radius: 8px;
        margin-bottom: 16px;
        overflow: hidden;
      }
      .section h3 {
        margin: 0;
        padding: 12px 16px;
        font-size: 0.8125rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        color: var(--accent);
        background: var(--accent-dim);
        border-bottom: 1px solid var(--border);
        cursor: grab;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .section h3:active { cursor: grabbing; }
      .section-title { pointer-events: none; }
      .section-toggle-indicator {
        font-family: var(--mono);
        font-size: 0.75rem;
        color: var(--text-muted);
        pointer-events: none;
      }
      .section.section-collapsed .section-inner {
        display: none;
      }
      .section-inner {
        padding: 16px;
      }
      .section pre {
        margin: 0;
        padding: 16px;
        font-family: "SF Mono", "Consolas", "Liberation Mono", Menlo, monospace;
        font-size: 0.8125rem;
        line-height: 1.5;
        background: var(--pre-bg);
        color: var(--text);
        overflow: auto;
        max-height: 320px;
        border: none;
      }
      .section pre:empty::before {
        content: "Loading…";
        color: var(--text-muted);
      }
      .status-grid {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 8px 16px;
        font-size: 0.875rem;
      }
      .status-grid dt {
        color: var(--text-muted);
        margin: 0;
      }
      .status-grid dd {
        margin: 0;
        font-family: "SF Mono", Consolas, monospace;
      }
      .status-ok { color: var(--success); }
      .metrics-blocks { display: flex; flex-direction: column; gap: 16px; }
      .metrics-block h4 { margin: 0 0 8px 0; font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; font-weight: 600; }
      .metrics-block pre { font-size: 0.75rem; max-height: 160px; margin: 0; }
      .metrics-table { width: 100%; border-collapse: collapse; font-size: 0.875rem; }
      .metrics-table td { padding: 6px 8px; border-bottom: 1px solid var(--border); }
      .metrics-table tr:last-child td { border-bottom: none; }
      .metric-name { font-family: var(--mono); color: var(--text-muted); font-size: 0.8125rem; }
      .metric-value { text-align: right; font-weight: 500; color: var(--text); }
      .metrics-empty { color: var(--text-muted); font-size: 0.875rem; font-style: italic; padding: 8px 0; }
      .logs-message {
        font-size: 0.8125rem;
        color: var(--text-muted);
        margin-bottom: 12px;
      }
      .table-wrap {
        overflow: auto;
        max-height: 400px;
        border: 1px solid var(--border);
        border-radius: 6px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.8125rem;
      }
      th, td {
        padding: 8px 12px;
        text-align: left;
        border-bottom: 1px solid var(--border);
      }
      th {
        background: var(--pre-bg);
        color: var(--accent);
        font-weight: 600;
        white-space: nowrap;
        cursor: pointer;
        user-select: none;
      }
      th:hover { text-decoration: underline; }
      tr:last-child td { border-bottom: none; }
      tr:hover td { background: var(--pre-bg); }
      .badge {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 0.75rem;
      }
      .badge-ok { background: var(--success); color: var(--bg); }
      .badge-anomaly { background: var(--error); color: #fff; }
      .poll-hint {
        font-size: 0.75rem;
        color: var(--text-muted);
        margin-top: 8px;
      }
      .main-layout {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
        margin-bottom: 16px;
      }
      .left-column, .right-column {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .dashboard-full-width {
        grid-column: 1 / -1;
      }
      .drag-ghost {
        opacity: 0.35;
      }
      .drag-chosen {
        outline: 2px dashed var(--accent);
      }
      .chart-container {
        min-height: 200px;
        position: relative;
      }
      .chart-wrapper {
        position: relative;
        height: 200px;
      }
      .cpu-chart-container {
        min-height: 160px;
        margin-top: 8px;
        position: relative;
      }
      .cpu-chart-wrapper {
        position: relative;
        height: 160px;
      }
      .map-wrapper {
        position: relative;
        height: 280px;
      }
      .capacity-summary {
        font-size: 0.875rem;
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 8px 12px;
      }
      .capacity-summary dt {
        color: var(--text-muted);
        margin: 0;
      }
      .capacity-summary dd {
        margin: 0;
      }
      .status-badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 600;
      }
      .status-ok-badge { background: var(--success); color: var(--bg); }
      .status-near-badge { background: #d29922; color: var(--bg); }
      .status-sat-badge { background: var(--error); color: #fff; }
      .map-note {
        color: var(--text-muted);
        font-size: 0.75rem;
        margin-top: 8px;
      }
      .anomaly-item {
        padding: 8px;
        border-bottom: 1px solid var(--border);
        font-size: 0.8125rem;
      }
      .anomaly-item:last-child {
        border-bottom: none;
      }
      .anomaly-score {
        font-weight: 600;
        color: var(--error);
      }
      .logs-full-width {
        width: 100%;
      }
      @media (max-width: 1200px) {
        .main-layout {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="header">
      <div>
        <h1>sentinel-ebpf</h1>
        <div class="subtitle">Lightweight status, metrics, and log tail.</div>
      </div>
      <div class="toggle-wrap">
        <span class="subtitle">Poll every %POLL_SECONDS%s</span>
        <button type="button" class="toggle-btn" id="theme-btn" aria-label="Toggle theme">Light</button>
      </div>
    </div>
    <div class="main-layout" id="dashboard-layout">
      <div class="left-column dashboard-column" id="left-column">
        <div class="section" data-widget-id="status">
          <h3>Status</h3>
          <div class="section-inner" id="status"></div>
        </div>
        <div class="section" data-widget-id="capacity">
          <h3>Capacity Guidance</h3>
          <div class="section-inner" id="capacity"></div>
        </div>
        <div class="section" data-widget-id="metrics">
          <h3>Metrics</h3>
          <div class="section-inner" id="metrics"></div>
        </div>
      </div>
      <div class="right-column dashboard-column" id="right-column">
        <div class="section" data-widget-id="score-map">
          <h3>Anomaly Score Map</h3>
          <div class="section-inner">
            <div class="map-wrapper">
              <canvas id="scoreMapChart"></canvas>
            </div>
            <div class="map-note">Feature-space map: X=path signature, Y=command signature, color/size by anomaly score.</div>
          </div>
        </div>
        <div class="section" data-widget-id="event-types">
          <h3>Event Types (per poll)</h3>
          <div class="section-inner">
            <div class="chart-container">
              <div class="chart-wrapper">
                <canvas id="chart"></canvas>
              </div>
            </div>
          </div>
        </div>
        <div class="section" data-widget-id="anomalies">
          <h3>Anomalies</h3>
          <div class="section-inner" id="anomalies"></div>
        </div>
      </div>
      <div class="dashboard-column dashboard-full-width" id="bottom-column">
        <div class="section logs-full-width" data-widget-id="logs">
          <h3>Logs (tail)</h3>
          <div class="section-inner" id="logs"></div>
        </div>
      </div>
    </div>
    <script>
      const pollSeconds = parseInt("%POLL_SECONDS%", 10) || 10;
      const logLimit = parseInt("%LOG_LIMIT%", 10) || 50;
      const themeBtn = document.getElementById("theme-btn");
      const html = document.documentElement;
      const layoutStorageKey = "sentinel-ui-layout-v1";
      const collapsedStorageKey = "sentinel-ui-collapsed-v1";
      let suppressToggleUntil = 0;

      function getDashboardColumns() {
        return [
          document.getElementById("left-column"),
          document.getElementById("right-column"),
          document.getElementById("bottom-column"),
        ].filter(Boolean);
      }

      function saveLayout() {
        const columns = getDashboardColumns();
        const payload = {};
        columns.forEach((col) => {
          payload[col.id] = Array.from(col.querySelectorAll(":scope > .section"))
            .map((sec) => sec.getAttribute("data-widget-id"))
            .filter(Boolean);
        });
        try { localStorage.setItem(layoutStorageKey, JSON.stringify(payload)); } catch (e) {}
      }

      function applySavedLayout() {
        let raw = null;
        try { raw = localStorage.getItem(layoutStorageKey); } catch (e) {}
        if (!raw) return;
        let layout = null;
        try { layout = JSON.parse(raw); } catch (e) { return; }
        if (!layout || typeof layout !== "object") return;

        const columns = getDashboardColumns();
        const widgetsById = {};
        columns.forEach((col) => {
          col.querySelectorAll(":scope > .section").forEach((sec) => {
            const id = sec.getAttribute("data-widget-id");
            if (id) widgetsById[id] = sec;
          });
        });

        columns.forEach((col) => {
          const ids = Array.isArray(layout[col.id]) ? layout[col.id] : [];
          ids.forEach((id) => {
            const sec = widgetsById[id];
            if (sec) col.appendChild(sec);
          });
        });
      }

      function initDragAndDropLayout() {
        if (typeof Sortable === "undefined") return;
        applySavedLayout();
        getDashboardColumns().forEach((col) => {
          Sortable.create(col, {
            group: "sentinel-dashboard",
            draggable: ".section",
            handle: ".section > h3",
            animation: 180,
            ghostClass: "drag-ghost",
            chosenClass: "drag-chosen",
            onEnd: function() {
              saveLayout();
              suppressToggleUntil = Date.now() + 250;
            },
          });
        });
      }
      function getCollapsedWidgets() {
        let raw = null;
        try { raw = localStorage.getItem(collapsedStorageKey); } catch (e) {}
        if (!raw) return new Set();
        try {
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed)) return new Set(parsed.filter(Boolean));
        } catch (e) {}
        return new Set();
      }
      function saveCollapsedWidgets(collapsedSet) {
        try { localStorage.setItem(collapsedStorageKey, JSON.stringify(Array.from(collapsedSet))); } catch (e) {}
      }
      function setSectionCollapsed(section, collapsed) {
        section.classList.toggle("section-collapsed", !!collapsed);
        const header = section.querySelector(":scope > h3");
        const indicator = header ? header.querySelector(".section-toggle-indicator") : null;
        if (header) header.setAttribute("aria-expanded", collapsed ? "false" : "true");
        if (indicator) indicator.textContent = collapsed ? "[+]" : "[-]";
      }
      function initSectionToggles() {
        const collapsedWidgets = getCollapsedWidgets();
        document.querySelectorAll(".section").forEach((section) => {
          const header = section.querySelector(":scope > h3");
          if (!header) return;
          if (!header.querySelector(".section-toggle-indicator")) {
            const title = header.textContent.trim();
            header.textContent = "";
            const titleSpan = document.createElement("span");
            titleSpan.className = "section-title";
            titleSpan.textContent = title;
            const indicator = document.createElement("span");
            indicator.className = "section-toggle-indicator";
            header.appendChild(titleSpan);
            header.appendChild(indicator);
          }
          header.setAttribute("role", "button");
          header.setAttribute("tabindex", "0");
          const widgetId = section.getAttribute("data-widget-id") || "";
          setSectionCollapsed(section, collapsedWidgets.has(widgetId));
          function toggleSection() {
            if (Date.now() < suppressToggleUntil) return;
            const isCollapsed = section.classList.contains("section-collapsed");
            setSectionCollapsed(section, !isCollapsed);
            if (!widgetId) return;
            if (isCollapsed) collapsedWidgets.delete(widgetId);
            else collapsedWidgets.add(widgetId);
            saveCollapsedWidgets(collapsedWidgets);
          }
          header.addEventListener("click", toggleSection);
          header.addEventListener("keydown", function(evt) {
            if (evt.key === "Enter" || evt.key === " ") {
              evt.preventDefault();
              toggleSection();
            }
          });
        });
      }
      function formatTimestampNs(nsLike) {
        if (nsLike == null) return "—";
        const nsNum = Number(nsLike);
        if (isNaN(nsNum) || nsNum <= 0) return "—";
        const ms = nsNum < 1e12 ? nsNum * 1000 : nsNum / 1e6;
        const date = new Date(ms);
        if (isNaN(date.getTime())) return "—";
        return date.toISOString().replace("T", " ").replace("Z", "");
      }
      function applyTheme(theme) {
        html.setAttribute("data-theme", theme === "light" ? "light" : "");
        themeBtn.textContent = theme === "light" ? "Dark" : "Light";
        try { localStorage.setItem("sentinel-ui-theme", theme); } catch (e) {}
      }
      let saved = null;
      try { saved = localStorage.getItem("sentinel-ui-theme"); } catch (e) {}
      if (saved === "light") applyTheme("light");
      else applyTheme("dark");
      themeBtn.addEventListener("click", function() {
        applyTheme(html.getAttribute("data-theme") === "light" ? "dark" : "light");
      });
      initDragAndDropLayout();
      initSectionToggles();
      async function fetchJson(url) {
        try {
          const r = await fetch(url);
          if (!r.ok) {
            throw new Error(`HTTP ${r.status}: ${r.statusText}`);
          }
          return await r.json();
        } catch (e) {
          console.error(`Failed to fetch ${url}:`, e);
          throw e;
        }
      }
      function renderStatus(data) {
        const el = document.getElementById("status");
        if (typeof data !== "object" || data === null) {
          el.innerHTML = "<pre>" + escapeHtml(String(data)) + "</pre>";
          return;
        }
        const items = [
          ["Timestamp", new Date((data.ts || 0) * 1000).toISOString()],
          ["Probe health", data.probe_health || "—"],
          ["Detector health", data.detector_health || "—"],
        ];
        if (data.detector_algorithm != null && data.detector_algorithm !== "") {
          items.push(["Detector algorithm", data.detector_algorithm]);
        }
        el.innerHTML = "<dl class=\"status-grid\">" +
          items.map(([k, v]) => "<dt>" + escapeHtml(k) + "</dt><dd class=\"" + (v === "ok" || v === "SERVING" ? "status-ok" : "") + "\">" + escapeHtml(String(v)) + "</dd>").join("") +
          "</dl>";
      }
      // Human-readable metric name mappings
      const metricNameMap = {
        "sentinel_ebpf_detector_events_total": "Events",
        "sentinel_ebpf_detector_anomalies_total": "Anomalies",
        "sentinel_ebpf_detector_errors_total": "Errors",
        "sentinel_ebpf_detector_last_event_timestamp_seconds": "Last Event",
        "sentinel_ebpf_detector_recent_events_count": "Recent Buffer",
        "sentinel_ebpf_probe_events_sent_total": "Sent",
        "sentinel_ebpf_probe_queue_size": "Queue Size",
        "sentinel_ebpf_probe_queue_capacity": "Queue Cap",
        "sentinel_ebpf_probe_events_dropped_total": "Dropped",
        "sentinel_ebpf_probe_host_cpu_usage_percent": "CPU %",
        "sentinel_ebpf_probe_host_memory_usage_percent": "Memory %",
        "sentinel_ebpf_probe_host_load1": "Load 1m"
      };
      
      // Track previous metrics for throughput calculation
      let previousMetrics = {
        events_total: null,
        timestamp: null
      };
      
      function parsePrometheusMetrics(text) {
        if (!text || typeof text !== "string") return [];
        const lines = text.split("\n").filter(l => l.trim() && !l.startsWith("#"));
        const metrics = [];
        for (const line of lines) {
          // Match metric name (can contain letters, numbers, underscores) followed by whitespace and value
          const match = line.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\s+(.+)$/);
          if (match) {
            const [, name, value] = match;
            const numValue = parseFloat(value);
            const readableName = metricNameMap[name] || name.replace(/_/g, " ").replace(/\b\w/g, l => l.toUpperCase());
            metrics.push({
              name: name,
              readableName: readableName,
              value: isNaN(numValue) ? value : numValue,
              displayValue: isNaN(numValue) ? value : numValue.toLocaleString()
            });
          }
        }
        return metrics;
      }
      function renderMetrics(data) {
        const el = document.getElementById("metrics");
        if (typeof data !== "object" || data === null) {
          el.innerHTML = "<pre>" + escapeHtml(String(data)) + "</pre>";
          return;
        }
        const probeText = data.probe_metrics != null ? String(data.probe_metrics) : "";
        const detectorText = data.detector_metrics != null ? String(data.detector_metrics) : "";
        const probeMetrics = parsePrometheusMetrics(probeText);
        const detectorMetrics = parsePrometheusMetrics(detectorText);
        
        // Calculate throughput for detector
        let throughput = null;
        const eventsTotalMetric = detectorMetrics.find(m => m.name === "sentinel_ebpf_detector_events_total");
        const currentTimestamp = data.ts || Date.now() / 1000;
        
        if (eventsTotalMetric && typeof eventsTotalMetric.value === "number") {
          const currentEvents = eventsTotalMetric.value;
          if (previousMetrics.events_total !== null && previousMetrics.timestamp !== null) {
            const timeDelta = currentTimestamp - previousMetrics.timestamp;
            const eventsDelta = currentEvents - previousMetrics.events_total;
            if (timeDelta > 0) {
              throughput = eventsDelta / timeDelta;
            }
          }
          previousMetrics.events_total = currentEvents;
          previousMetrics.timestamp = currentTimestamp;
        }
        
        function renderMetricsTable(metrics, title, extraRows = []) {
          if (metrics.length === 0 && extraRows.length === 0) {
            return `<div class="metrics-block"><h4>${title}</h4><div class="metrics-empty">No data</div></div>`;
          }
          const allRows = [
            ...metrics.map(m => 
              `<tr><td class="metric-name">${escapeHtml(m.readableName)}</td><td class="metric-value">${escapeHtml(String(m.displayValue))}</td></tr>`
            ),
            ...extraRows
          ];
          return `<div class="metrics-block"><h4>${title}</h4><table class="metrics-table"><tbody>${allRows.join("")}</tbody></table></div>`;
        }
        
        const detectorExtraRows = [];
        if (throughput !== null && !isNaN(throughput) && throughput >= 0) {
          const throughputFormatted = throughput >= 1000 
            ? `${(throughput / 1000).toFixed(2)}k events/s`
            : `${throughput.toFixed(2)} events/s`;
          detectorExtraRows.push(
            `<tr><td class="metric-name">Throughput</td><td class="metric-value">${escapeHtml(throughputFormatted)}</td></tr>`
          );
        }
        
        const probeHtml = probeMetrics.length > 0 
          ? renderMetricsTable(probeMetrics, "Probe")
          : `<div class="metrics-block"><h4>Probe</h4><div class="metrics-empty">No data</div></div>`;
        
        const detectorHtml = detectorMetrics.length > 0 || detectorExtraRows.length > 0
          ? renderMetricsTable(detectorMetrics, "Detector", detectorExtraRows)
          : `<div class="metrics-block"><h4>Detector</h4><div class="metrics-empty">No detector metrics (gRPC only)</div></div>`;
        
        el.innerHTML = `<div class="metrics-blocks">${probeHtml}${detectorHtml}</div>`;
      }
      function renderCapacity(data) {
        const el = document.getElementById("capacity");
        if (typeof data !== "object" || data === null) {
          el.innerHTML = "<div class=\"metrics-empty\">Capacity data unavailable</div>";
          return;
        }
        const host = data.host || {};
        const pipe = data.pipeline || {};
        let badgeClass = "status-ok-badge";
        if (data.status === "Near Limit") badgeClass = "status-near-badge";
        if (data.status === "Saturated") badgeClass = "status-sat-badge";
        const queueRatio = (pipe.queue_fill_ratio == null) ? "n/a" : String(pipe.queue_fill_ratio);
        const hostMetricsNote = host.has_host_metrics
          ? ""
          : "<div class=\"map-note\" style=\"margin-top:6px;\">Host metrics not available yet. Restart probe pod to expose new host CPU/memory/load metrics.</div>";
        el.innerHTML =
          `<div style="margin-bottom:8px;"><span class="status-badge ${badgeClass}">${escapeHtml(String(data.status || "Unknown"))}</span></div>` +
          `<dl class="capacity-summary">` +
          `<dt>CPU</dt><dd>${escapeHtml(String(host.cpu_usage_percent ?? 0))}%</dd>` +
          `<dt>Memory</dt><dd>${escapeHtml(String(host.memory_usage_percent ?? 0))}%</dd>` +
          `<dt>Load (1m)</dt><dd>${escapeHtml(String(host.load1 ?? 0))} / ${escapeHtml(String(host.cpu_count ?? 1))} cores</dd>` +
          `<dt>Queue</dt><dd>${escapeHtml(String(pipe.queue_size ?? 0))}/${escapeHtml(String(pipe.queue_capacity ?? 0))} (${escapeHtml(queueRatio)})</dd>` +
          `<dt>Drops</dt><dd>${escapeHtml(String(pipe.drops_total ?? 0))}</dd>` +
          `<dt>New Drops</dt><dd>${escapeHtml(String(pipe.drops_delta ?? 0))}</dd>` +
          `<dt>Detector EPS</dt><dd>${escapeHtml(String(pipe.detector_events_per_sec ?? 0))}</dd>` +
          `</dl>` +
          `<div class="map-note" style="margin-top:10px;">${escapeHtml(String(data.replica_hint || ""))}</div>` +
          `<div class="map-note" style="margin-top:10px;">CPU usage over time (per poll)</div>` +
          `<div class="cpu-chart-container"><div class="cpu-chart-wrapper"><canvas id="cpuChart"></canvas></div></div>` +
          hostMetricsNote;
        renderCpuUsageChart(data);
      }
      const cpuHistory = [];
      const cpuHistoryMaxPoints = 20;
      let cpuChartInstance = null;
      let cpuChartLastSignature = "";
      function renderCpuUsageChart(capacityData) {
        const canvas = document.getElementById("cpuChart");
        if (!canvas || typeof Chart === "undefined") return;
        if (cpuChartInstance && cpuChartInstance.canvas !== canvas) {
          cpuChartInstance.destroy();
          cpuChartInstance = null;
          cpuChartLastSignature = "";
        }
        const host = capacityData && typeof capacityData === "object" ? (capacityData.host || {}) : {};
        if (!host.has_host_metrics) return;
        const cpuPercent = Number(host.cpu_usage_percent);
        const tsSeconds = Number(capacityData.ts);
        if (!Number.isFinite(cpuPercent)) return;
        const pointTs = Number.isFinite(tsSeconds) && tsSeconds > 0 ? tsSeconds : Math.floor(Date.now() / 1000);
        const lastPoint = cpuHistory[cpuHistory.length - 1];
        if (!lastPoint || lastPoint.ts !== pointTs) {
          cpuHistory.push({ ts: pointTs, cpu: cpuPercent });
          while (cpuHistory.length > cpuHistoryMaxPoints) cpuHistory.shift();
        } else {
          lastPoint.cpu = cpuPercent;
        }
        const labels = cpuHistory.map((p) =>
          new Date(p.ts * 1000).toISOString().split("T")[1].split(".")[0]
        );
        const values = cpuHistory.map((p) => p.cpu);
        const chartSignature = JSON.stringify({ labels, values });
        if (cpuChartInstance && cpuChartLastSignature === chartSignature) return;
        const isDark = document.documentElement.getAttribute("data-theme") !== "light";
        const textColor = isDark ? "#e6edf3" : "#1f2328";
        const gridColor = isDark ? "#2d3a4f" : "#d0d7de";
        const lineColor = isDark ? "#79c0ff" : "#0969da";
        if (cpuChartInstance) {
          cpuChartInstance.data.labels = labels;
          cpuChartInstance.data.datasets[0].data = values;
          cpuChartInstance.data.datasets[0].borderColor = lineColor;
          cpuChartInstance.data.datasets[0].backgroundColor = lineColor + "33";
          cpuChartInstance.options.scales.x.ticks.color = textColor;
          cpuChartInstance.options.scales.x.grid.color = gridColor;
          cpuChartInstance.options.scales.y.ticks.color = textColor;
          cpuChartInstance.options.scales.y.grid.color = gridColor;
          cpuChartInstance.update("none");
        } else {
          cpuChartInstance = new Chart(canvas, {
            type: "line",
            data: {
              labels: labels,
              datasets: [{
                label: "CPU %",
                data: values,
                borderColor: lineColor,
                backgroundColor: lineColor + "33",
                borderWidth: 2,
                tension: 0.25,
                fill: true,
                pointRadius: 3,
                pointHoverRadius: 5
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 250 },
              plugins: {
                legend: {
                  display: true,
                  position: "top",
                  labels: { color: textColor, usePointStyle: true }
                },
                tooltip: {
                  enabled: true,
                  mode: "index",
                  intersect: false
                }
              },
              scales: {
                y: {
                  beginAtZero: true,
                  min: 0,
                  max: 100,
                  ticks: { color: textColor },
                  grid: { color: gridColor }
                },
                x: {
                  ticks: { color: textColor },
                  grid: { color: gridColor }
                }
              }
            }
          });
        }
        cpuChartLastSignature = chartSignature;
      }
      let logsSortKey = "ts_unix_nano";
      let logsSortDir = "desc";
      let lastLogsData = null;
      function renderLogs(data) {
        lastLogsData = data;
        const el = document.getElementById("logs");
        if (typeof data !== "object" || data === null) {
          el.innerHTML = "<pre>" + escapeHtml(String(data)) + "</pre>";
          return;
        }
        const message = data.message || "";
        let entries = Array.isArray(data.entries) ? data.entries : [];
        function extractEventFields(entry) {
          const d = Array.isArray(entry?.data) ? entry.data : [];
          return {
            comm: (d.length > 2 && d[2] !== "") ? d[2] : (entry.comm || "—"),
            pid: (d.length > 3 && d[3] !== "") ? d[3] : (entry.pid || "—"),
            tid: (d.length > 4 && d[4] !== "") ? d[4] : (entry.tid || "—"),
            uid: (d.length > 5 && d[5] !== "") ? d[5] : (entry.uid || "—"),
            path: (d.length > 8 && d[8] !== "") ? d[8] : (d.length > 0 ? d[0] : (entry.path || entry.prefix || "—")),
          };
        }
        function getCell(entry, key) {
          const fields = extractEventFields(entry);
          if (key === "ts_unix_nano") {
            return formatTimestampNs(entry.ts_unix_nano);
          }
          if (key === "comm") return fields.comm;
          if (key === "path") return fields.path;
          if (key === "pid_tid_uid") return `${fields.pid}/${fields.tid}/${fields.uid}`;
          const v = entry[key];
          if (v === true || v === false) return v ? "Yes" : "No";
          return v != null ? String(v) : "—";
        }
        function compare(a, b) {
          const va = getCell(a, logsSortKey);
          const vb = getCell(b, logsSortKey);
          if (logsSortKey === "ts_unix_nano") {
            const na = Number(a.ts_unix_nano);
            const nb = Number(b.ts_unix_nano);
            return logsSortDir === "asc" ? na - nb : nb - na;
          }
          if (logsSortKey === "anomaly" || logsSortKey === "score") {
            const na = Number(a[logsSortKey]);
            const nb = Number(b[logsSortKey]);
            if (!isNaN(na) && !isNaN(nb)) return logsSortDir === "asc" ? na - nb : nb - na;
          }
          const c = String(va).localeCompare(String(vb));
          return logsSortDir === "asc" ? c : -c;
        }
        entries = entries.slice().sort(compare);
        const headers = [
          { key: "ts_unix_nano", label: "Time" },
          { key: "event_type", label: "Type" },
          { key: "hostname", label: "Host" },
          { key: "comm", label: "Comm" },
          { key: "path", label: "Path" },
          { key: "pid_tid_uid", label: "PID/TID/UID" },
          { key: "anomaly", label: "Anomaly" },
          { key: "score", label: "Score" },
          { key: "reason", label: "Reason" },
        ];
        let table = "<div class=\"logs-message\">" + escapeHtml(message || (entries.length ? "Live tail from detector." : "No events yet.")) + "</div>";
        if (entries.length === 0) {
          table += "<p class=\"logs-message\">No entries.</p>";
        } else {
          table += "<div class=\"table-wrap\"><table><thead><tr>";
          headers.forEach(function(h) {
            const sort = h.key === logsSortKey ? logsSortDir : "";
            let arrow = "";
            if (sort === "asc") arrow = " ↑";
            else if (sort === "desc") arrow = " ↓";
            else if (sort === "") arrow = " ↕";
            table += "<th data-sort=\"" + sort + "\" data-key=\"" + escapeHtml(h.key) + "\">" + escapeHtml(h.label) + arrow + "</th>";
          });
          table += "</tr></thead><tbody>";
          entries.forEach(function(entry) {
            table += "<tr>";
            headers.forEach(function(h) {
              let cell = getCell(entry, h.key);
              if (h.key === "anomaly" && (entry.anomaly === true || cell === "Yes")) {
                cell = "<span class=\"badge badge-anomaly\">Yes</span>";
              } else if (h.key === "anomaly" && (entry.anomaly === false || cell === "No")) {
                cell = "<span class=\"badge badge-ok\">No</span>";
              } else {
                cell = escapeHtml(cell);
              }
              table += "<td>" + cell + "</td>";
            });
            table += "</tr>";
          });
          table += "</tbody></table></div>";
        }
        el.innerHTML = table;
        el.querySelectorAll("th[data-key]").forEach(function(th) {
          th.addEventListener("click", function() {
            const key = th.getAttribute("data-key");
            if (key === logsSortKey) logsSortDir = logsSortDir === "asc" ? "desc" : "asc";
            else { logsSortKey = key; logsSortDir = "asc"; }
            if (lastLogsData) renderLogs(lastLogsData);
          });
        });
      }
      function escapeHtml(s) {
        const div = document.createElement("div");
        div.textContent = s;
        return div.innerHTML;
      }
      let scoreMapInstance = null;
      let scoreMapLastSignature = "";
      let scoreMapHasRendered = false;
      function renderScoreMap(data) {
        const canvas = document.getElementById("scoreMapChart");
        if (!canvas) return;
        const points = Array.isArray(data?.points) ? data.points : [];
        if (typeof Chart === "undefined") return;
        if (points.length === 0) {
          if (scoreMapInstance) {
            scoreMapInstance.destroy();
            scoreMapInstance = null;
          }
          return;
        }
        const isDark = document.documentElement.getAttribute("data-theme") !== "light";
        const textColor = isDark ? "#e6edf3" : "#1f2328";
        const gridColor = isDark ? "#2d3a4f" : "#d0d7de";

        function pointColor(score, anomaly) {
          const clamped = Math.max(0, Math.min(1, Number(score) || 0));
          const r = Math.round(255 * clamped);
          const g = Math.round(255 * (1 - clamped));
          const alpha = anomaly ? 0.9 : 0.6;
          return `rgba(${r},${g},80,${alpha})`;
        }
        const datasetPoints = points.map(p => ({
          x: Number(p.x) || 0,
          y: Number(p.y) || 0,
          score: Number(p.score) || 0,
          anomaly: !!p.anomaly,
          reason: p.reason || "",
          path: p.path || "",
          comm: p.comm || "",
          pid: p.pid || "",
          tid: p.tid || "",
          uid: p.uid || "",
          hostname: p.hostname || "",
          event_type: p.event_type || "",
          ts_unix_nano: p.ts_unix_nano || 0
        }));
        const scoreMapSignature = JSON.stringify(datasetPoints.map(p => [
          p.x, p.y, p.score, p.anomaly ? 1 : 0, p.ts_unix_nano
        ]));
        if (scoreMapInstance && scoreMapLastSignature === scoreMapSignature) {
          return;
        }
        const config = {
          type: "scatter",
          data: {
            datasets: [{
              label: "Events",
              data: datasetPoints,
              pointBackgroundColor: (ctx) => {
                const raw = ctx.raw || {};
                return pointColor(raw.score, raw.anomaly);
              },
              pointRadius: (ctx) => {
                const raw = ctx.raw || {};
                const base = raw.anomaly ? 4 : 2;
                return base + Math.round((raw.score || 0) * 4);
              },
              pointHoverRadius: 8
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: { duration: 350 },
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  title: (items) => {
                    if (!items || !items.length) return "";
                    const raw = items[0].raw || {};
                    return `${raw.event_type || "event"} @ ${formatTimestampNs(raw.ts_unix_nano)}`;
                  },
                  label: (item) => {
                    const raw = item.raw || {};
                    return `score=${Number(raw.score || 0).toFixed(3)} anomaly=${raw.anomaly ? "yes" : "no"}`;
                  },
                  afterLabel: (item) => {
                    const raw = item.raw || {};
                    return [
                      `host=${raw.hostname || "-"}`,
                      `comm=${raw.comm || "-"}`,
                      `path=${raw.path || "-"}`,
                      `pid/tid/uid=${raw.pid || "-"}/${raw.tid || "-"}/${raw.uid || "-"}`,
                      `reason=${raw.reason || "-"}`
                    ];
                  }
                }
              }
            },
            scales: {
              x: {
                min: 0, max: 1,
                title: { display: true, text: "Path Signature", color: textColor },
                ticks: { color: textColor },
                grid: { color: gridColor }
              },
              y: {
                min: 0, max: 1,
                title: { display: true, text: "Command Signature", color: textColor },
                ticks: { color: textColor },
                grid: { color: gridColor }
              }
            }
          }
        };
        if (scoreMapInstance) {
          scoreMapInstance.data = config.data;
          scoreMapInstance.options = config.options;
          scoreMapInstance.update(scoreMapHasRendered ? "none" : undefined);
        } else {
          scoreMapInstance = new Chart(canvas, config);
          scoreMapHasRendered = true;
        }
        scoreMapLastSignature = scoreMapSignature;
      }
      let chartInstance = null;
      let chartLastSignature = "";
      let chartHasRendered = false;
      function renderChart(data) {
        const container = document.querySelector(".chart-container");
        if (!container) {
          console.error("Chart container not found");
          return;
        }
        
        // Check if Chart.js is loaded
        if (typeof Chart === "undefined") {
          container.innerHTML = "<div class=\"metrics-empty\">Chart.js library not loaded</div>";
          console.error("Chart.js not loaded");
          return;
        }
        
        // Ensure canvas exists first, before checking data
        let canvas = document.getElementById("chart");
        let wrapper = canvas ? canvas.closest(".chart-wrapper") : null;
        if (!canvas || !wrapper) {
          // Create canvas if it doesn't exist
          wrapper = document.createElement("div");
          wrapper.className = "chart-wrapper";
          canvas = document.createElement("canvas");
          canvas.id = "chart";
          wrapper.appendChild(canvas);
          container.innerHTML = "";
          container.appendChild(wrapper);
        }
        
        if (typeof data !== "object" || data === null || !data.time_buckets) {
          if (chartInstance) {
            chartInstance.destroy();
            chartInstance = null;
          }
          // Don't clear container, just hide/show message
          const existingMsg = container.querySelector(".metrics-empty");
          if (!existingMsg) {
            const msg = document.createElement("div");
            msg.className = "metrics-empty";
            msg.textContent = "No data available";
            wrapper.style.display = "none";
            container.appendChild(msg);
          }
          console.log("No chart data:", data);
          return;
        }
        
        const timeBuckets = data.time_buckets || [];
        if (timeBuckets.length === 0) {
          if (chartInstance) {
            chartInstance.destroy();
            chartInstance = null;
          }
          // Don't clear container, just hide/show message
          const existingMsg = container.querySelector(".metrics-empty");
          if (!existingMsg) {
            const msg = document.createElement("div");
            msg.className = "metrics-empty";
            msg.textContent = "No events in this poll interval";
            wrapper.style.display = "none";
            container.appendChild(msg);
          }
          return;
        }
        
        // Hide any "no data" messages and show chart
        const existingMsg = container.querySelector(".metrics-empty");
        if (existingMsg) {
          existingMsg.remove();
        }
        wrapper.style.display = "block";
        
        // Collect all unique event types across all time buckets
        const eventTypes = new Set();
        timeBuckets.forEach(bucket => {
          Object.keys(bucket.counts || {}).forEach(type => eventTypes.add(type));
        });
        const sortedEventTypes = Array.from(eventTypes).sort();
        
        // Extract time labels (x-axis)
        const timeLabels = timeBuckets.map(bucket => bucket.time);
        
        // Create datasets: one per event type
        const isDark = document.documentElement.getAttribute("data-theme") !== "light";
        const textColor = isDark ? "#e6edf3" : "#1f2328";
        const gridColor = isDark ? "#2d3a4f" : "#d0d7de";
        
        // Color palette for different event types
        const colors = [
          isDark ? "#58a6ff" : "#0969da",  // Blue
          isDark ? "#f85149" : "#cf222e",  // Red
          isDark ? "#3fb950" : "#1a7f37",  // Green
          isDark ? "#d29922" : "#9a6700",  // Yellow/Orange
          isDark ? "#a371f7" : "#8250df",  // Purple
          isDark ? "#79c0ff" : "#0969da",  // Light Blue
          isDark ? "#ff7b72" : "#cf222e",  // Light Red
          isDark ? "#7ee787" : "#1a7f37",  // Light Green
        ];
        
        const datasets = sortedEventTypes.map((eventType, idx) => {
          const color = colors[idx % colors.length];
          return {
            label: eventType,
            data: timeBuckets.map(bucket => bucket.counts[eventType] || 0),
            backgroundColor: color + "80",
            borderColor: color,
            borderWidth: 1
          };
        });
        const chartSignature = JSON.stringify({
          labels: timeLabels,
          datasets: datasets.map(d => ({ label: d.label, data: d.data }))
        });
        if (chartInstance && chartLastSignature === chartSignature) {
          return;
        }
        
        try {
          if (chartInstance) {
            chartInstance.data.labels = timeLabels;
            chartInstance.data.datasets = datasets;
            chartInstance.update(chartHasRendered ? "none" : undefined);
          } else {
            if (!canvas || !canvas.parentElement) {
              console.error("Canvas not found or not in DOM");
              return;
            }
            chartInstance = new Chart(canvas, {
              type: "bar",
              data: {
                labels: timeLabels,
                datasets: datasets
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: { duration: 350 },
                plugins: {
                  legend: {
                    display: true,
                    position: "top",
                    labels: {
                      color: textColor,
                      usePointStyle: true
                    }
                  },
                  tooltip: {
                    enabled: true,
                    mode: "index",
                    intersect: false
                  }
                },
                scales: {
                  y: {
                    beginAtZero: true,
                    stacked: false,
                    ticks: {
                      color: textColor,
                      precision: 0
                    },
                    grid: {
                      color: gridColor
                    }
                  },
                  x: {
                    stacked: false,
                    ticks: {
                      color: textColor
                    },
                    grid: {
                      color: gridColor
                    }
                  }
                }
              }
            });
            console.log("Chart created successfully");
            chartHasRendered = true;
          }
          chartLastSignature = chartSignature;
        } catch (e) {
          console.error("Error rendering chart:", e);
          container.innerHTML = "<div class=\"metrics-empty\">Error rendering chart: " + escapeHtml(String(e)) + "</div>";
        }
      }

      function renderAnomalies(data) {
        const el = document.getElementById("anomalies");
        if (typeof data !== "object" || data === null) {
          el.innerHTML = "<pre>" + escapeHtml(String(data)) + "</pre>";
          return;
        }
        const entries = Array.isArray(data.entries) ? data.entries : [];
        if (entries.length === 0) {
          el.innerHTML = "<div class=\"metrics-empty\">No anomalies detected</div>";
          return;
        }
        let html = `<div style="max-height: 400px; overflow-y: auto;">`;
        entries.slice().reverse().forEach(entry => {
          const ts = formatTimestampNs(entry.ts_unix_nano);
          const path = Array.isArray(entry.data) && entry.data.length > 8
            ? (entry.data[8] || "—")
            : (Array.isArray(entry.data) && entry.data.length > 0 ? entry.data[0] : "—");
          html += `<div class="anomaly-item">`;
          html += `<div><strong>${escapeHtml(ts)}</strong> <span class="anomaly-score">Score: ${escapeHtml(String(entry.score || 0))}</span></div>`;
          html += `<div style="color: var(--text-muted); font-size: 0.75rem; margin-top: 4px;">${escapeHtml(path)}</div>`;
          html += `<div style="color: var(--text-muted); font-size: 0.75rem; margin-top: 2px;">${escapeHtml(entry.reason || "")}</div>`;
          html += `</div>`;
        });
        html += `</div>`;
        el.innerHTML = html;
      }

      async function refresh() {
        try {
          const status = await fetchJson("/api/status");
          renderStatus(status);
        } catch (e) {
          const statusEl = document.getElementById("status");
          if (statusEl) {
            statusEl.innerHTML = "<div class=\"metrics-empty\">Error loading status: " + escapeHtml(String(e)) + "</div>";
          }
        }
        try {
          const metrics = await fetchJson("/api/metrics");
          renderMetrics(metrics);
        } catch (e) {
          const metricsEl = document.getElementById("metrics");
          if (metricsEl) {
            metricsEl.innerHTML = "<div class=\"metrics-empty\">Error loading metrics: " + escapeHtml(String(e)) + "</div>";
          }
        }
        try {
          const capacity = await fetchJson("/api/capacity");
          renderCapacity(capacity);
        } catch (e) {
          const capEl = document.getElementById("capacity");
          if (capEl) {
            capEl.innerHTML = "<div class=\"metrics-empty\">Error loading capacity: " + escapeHtml(String(e)) + "</div>";
          }
        }
        try {
          const scoreMap = await fetchJson("/api/score_map?limit=800");
          renderScoreMap(scoreMap);
        } catch (e) {
          console.error("Error loading score map:", e);
        }
        try {
          const chart = await fetchJson("/api/calls_chart");
          renderChart(chart);
        } catch (e) {
          const container = document.querySelector(".chart-container");
          if (container) {
            container.innerHTML = "<div class=\"metrics-empty\">Error loading chart: " + escapeHtml(String(e)) + "</div>";
          }
        }
        try {
          const anomalies = await fetchJson("/api/anomalies?limit=100");
          renderAnomalies(anomalies);
        } catch (e) {
          const anomaliesEl = document.getElementById("anomalies");
          if (anomaliesEl) {
            anomaliesEl.innerHTML = "<div class=\"metrics-empty\">Error loading anomalies: " + escapeHtml(String(e)) + "</div>";
          }
        }
        try {
          const logs = await fetchJson("/api/logs?limit=" + logLimit);
          renderLogs(logs);
        } catch (e) {
          const logsEl = document.getElementById("logs");
          if (logsEl) {
            logsEl.innerHTML = "<div class=\"metrics-empty\">Error loading logs: " + escapeHtml(String(e)) + "</div>";
          }
        }
      }
      refresh();
      setInterval(refresh, pollSeconds * 1000);
    </script>
  </body>
</html>

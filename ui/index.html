<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>sentinel-ebpf debug</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js"></script>
    <style>
      :root {
        --mono: "SF Mono", "Consolas", "Liberation Mono", Menlo, monospace;
        --bg: #0f1419;
        --bg-card: #1a2332;
        --border: #2d3a4f;
        --text: #e6edf3;
        --text-muted: #8b949e;
        --accent: #58a6ff;
        --accent-dim: #388bfd66;
        --pre-bg: #161b22;
        --success: #3fb950;
        --error: #f85149;
      }
      [data-theme="light"] {
        --bg: #f0f2f5;
        --bg-card: #ffffff;
        --border: #d0d7de;
        --text: #1f2328;
        --text-muted: #656d76;
        --accent: #0969da;
        --accent-dim: #0969da22;
        --pre-bg: #f6f8fa;
      }
      * { box-sizing: border-box; }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
        background: var(--bg);
        color: var(--text);
        margin: 0;
        padding: 24px;
        line-height: 1.5;
        min-height: 100vh;
      }
      .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 12px;
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 1px solid var(--border);
      }
      .header h1 {
        margin: 0;
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--text);
        letter-spacing: -0.02em;
      }
      .header .subtitle {
        color: var(--text-muted);
        font-size: 0.875rem;
      }
      .toggle-wrap {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .toggle-btn {
        background: var(--bg-card);
        color: var(--text);
        border: 1px solid var(--border);
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 0.8125rem;
        cursor: pointer;
        transition: background 0.15s, border-color 0.15s;
      }
      .toggle-btn:hover {
        background: var(--border);
      }
      .section {
        background: var(--bg-card);
        border: 1px solid var(--border);
        border-radius: 8px;
        margin-bottom: 16px;
        overflow: hidden;
      }
      .section h3 {
        margin: 0;
        padding: 12px 16px;
        font-size: 0.8125rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        color: var(--accent);
        background: var(--accent-dim);
        border-bottom: 1px solid var(--border);
      }
      .section-inner {
        padding: 16px;
      }
      .section pre {
        margin: 0;
        padding: 16px;
        font-family: "SF Mono", "Consolas", "Liberation Mono", Menlo, monospace;
        font-size: 0.8125rem;
        line-height: 1.5;
        background: var(--pre-bg);
        color: var(--text);
        overflow: auto;
        max-height: 320px;
        border: none;
      }
      .section pre:empty::before {
        content: "Loading…";
        color: var(--text-muted);
      }
      .status-grid {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 8px 16px;
        font-size: 0.875rem;
      }
      .status-grid dt {
        color: var(--text-muted);
        margin: 0;
      }
      .status-grid dd {
        margin: 0;
        font-family: "SF Mono", Consolas, monospace;
      }
      .status-ok { color: var(--success); }
      .metrics-blocks { display: flex; flex-direction: column; gap: 16px; }
      .metrics-block h4 { margin: 0 0 8px 0; font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; font-weight: 600; }
      .metrics-block pre { font-size: 0.75rem; max-height: 160px; margin: 0; }
      .metrics-table { width: 100%; border-collapse: collapse; font-size: 0.875rem; }
      .metrics-table td { padding: 6px 8px; border-bottom: 1px solid var(--border); }
      .metrics-table tr:last-child td { border-bottom: none; }
      .metric-name { font-family: var(--mono); color: var(--text-muted); font-size: 0.8125rem; }
      .metric-value { text-align: right; font-weight: 500; color: var(--text); }
      .metrics-empty { color: var(--text-muted); font-size: 0.875rem; font-style: italic; padding: 8px 0; }
      .logs-message {
        font-size: 0.8125rem;
        color: var(--text-muted);
        margin-bottom: 12px;
      }
      .table-wrap {
        overflow: auto;
        max-height: 400px;
        border: 1px solid var(--border);
        border-radius: 6px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.8125rem;
      }
      th, td {
        padding: 8px 12px;
        text-align: left;
        border-bottom: 1px solid var(--border);
      }
      th {
        background: var(--pre-bg);
        color: var(--accent);
        font-weight: 600;
        white-space: nowrap;
        cursor: pointer;
        user-select: none;
      }
      th:hover { text-decoration: underline; }
      tr:last-child td { border-bottom: none; }
      tr:hover td { background: var(--pre-bg); }
      .badge {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 0.75rem;
      }
      .badge-ok { background: var(--success); color: var(--bg); }
      .badge-anomaly { background: var(--error); color: #fff; }
      .poll-hint {
        font-size: 0.75rem;
        color: var(--text-muted);
        margin-top: 8px;
      }
      .main-layout {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
        margin-bottom: 16px;
      }
      .left-column, .right-column {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .chart-container {
        min-height: 200px;
        position: relative;
      }
      .chart-wrapper {
        position: relative;
        height: 200px;
      }
      .anomaly-item {
        padding: 8px;
        border-bottom: 1px solid var(--border);
        font-size: 0.8125rem;
      }
      .anomaly-item:last-child {
        border-bottom: none;
      }
      .anomaly-score {
        font-weight: 600;
        color: var(--error);
      }
      .logs-full-width {
        width: 100%;
      }
      @media (max-width: 1200px) {
        .main-layout {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="header">
      <div>
        <h1>sentinel-ebpf</h1>
        <div class="subtitle">Lightweight status, metrics, and log tail.</div>
      </div>
      <div class="toggle-wrap">
        <span class="subtitle">Poll every %POLL_SECONDS%s</span>
        <button type="button" class="toggle-btn" id="theme-btn" aria-label="Toggle theme">Light</button>
      </div>
    </div>
    <div class="main-layout">
      <div class="left-column">
        <div class="section">
          <h3>Status</h3>
          <div class="section-inner" id="status"></div>
        </div>
        <div class="section">
          <h3>Metrics</h3>
          <div class="section-inner" id="metrics"></div>
        </div>
      </div>
      <div class="right-column">
        <div class="section">
          <h3>Event Types (per poll)</h3>
          <div class="section-inner">
            <div class="chart-container">
              <div class="chart-wrapper">
                <canvas id="chart"></canvas>
              </div>
            </div>
          </div>
        </div>
        <div class="section">
          <h3>Anomalies</h3>
          <div class="section-inner" id="anomalies"></div>
        </div>
      </div>
    </div>
    <div class="section logs-full-width">
      <h3>Logs (tail)</h3>
      <div class="section-inner" id="logs"></div>
    </div>
    <script>
      const pollSeconds = parseInt("%POLL_SECONDS%", 10) || 10;
      const logLimit = parseInt("%LOG_LIMIT%", 10) || 50;
      const themeBtn = document.getElementById("theme-btn");
      const html = document.documentElement;
      function formatTimestampNs(nsLike) {
        if (nsLike == null) return "—";
        const nsNum = Number(nsLike);
        if (isNaN(nsNum) || nsNum <= 0) return "—";
        const ms = nsNum < 1e12 ? nsNum * 1000 : nsNum / 1e6;
        const date = new Date(ms);
        if (isNaN(date.getTime())) return "—";
        return date.toISOString().replace("T", " ").replace("Z", "");
      }
      function applyTheme(theme) {
        html.setAttribute("data-theme", theme === "light" ? "light" : "");
        themeBtn.textContent = theme === "light" ? "Dark" : "Light";
        try { localStorage.setItem("sentinel-ui-theme", theme); } catch (e) {}
      }
      let saved = null;
      try { saved = localStorage.getItem("sentinel-ui-theme"); } catch (e) {}
      if (saved === "light") applyTheme("light");
      else applyTheme("dark");
      themeBtn.addEventListener("click", function() {
        applyTheme(html.getAttribute("data-theme") === "light" ? "dark" : "light");
      });
      async function fetchJson(url) {
        try {
          const r = await fetch(url);
          if (!r.ok) {
            throw new Error(`HTTP ${r.status}: ${r.statusText}`);
          }
          return await r.json();
        } catch (e) {
          console.error(`Failed to fetch ${url}:`, e);
          throw e;
        }
      }
      function renderStatus(data) {
        const el = document.getElementById("status");
        if (typeof data !== "object" || data === null) {
          el.innerHTML = "<pre>" + escapeHtml(String(data)) + "</pre>";
          return;
        }
        const items = [
          ["Timestamp", new Date((data.ts || 0) * 1000).toISOString()],
          ["Probe health", data.probe_health || "—"],
          ["Detector health", data.detector_health || "—"],
        ];
        if (data.detector_algorithm != null && data.detector_algorithm !== "") {
          items.push(["Detector algorithm", data.detector_algorithm]);
        }
        if (data.detector_worker_count != null) {
          items.push(["Detector workers", data.detector_worker_count]);
        }
        el.innerHTML = "<dl class=\"status-grid\">" +
          items.map(([k, v]) => "<dt>" + escapeHtml(k) + "</dt><dd class=\"" + (v === "ok" || v === "SERVING" ? "status-ok" : "") + "\">" + escapeHtml(String(v)) + "</dd>").join("") +
          "</dl>";
      }
      // Human-readable metric name mappings
      const metricNameMap = {
        "sentinel_ebpf_detector_events_total": "Events Processed",
        "sentinel_ebpf_detector_anomalies_total": "Anomalies Detected",
        "sentinel_ebpf_detector_errors_total": "Errors",
        "sentinel_ebpf_detector_last_event_timestamp_seconds": "Last Event Time",
        "sentinel_ebpf_detector_recent_events_count": "Recent Events Buffer",
        "sentinel_ebpf_detector_worker_count": "Worker Threads",
        "sentinel_ebpf_probe_events_sent_total": "Events Sent",
        "sentinel_ebpf_probe_queue_size": "Queue Size",
        "sentinel_ebpf_probe_events_dropped_total": "Events Dropped"
      };
      
      // Track previous metrics for throughput calculation
      let previousMetrics = {
        events_total: null,
        timestamp: null
      };
      
      function parsePrometheusMetrics(text) {
        if (!text || typeof text !== "string") return [];
        const lines = text.split("\n").filter(l => l.trim() && !l.startsWith("#"));
        const metrics = [];
        for (const line of lines) {
          // Match metric name (can contain letters, numbers, underscores) followed by whitespace and value
          const match = line.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\s+(.+)$/);
          if (match) {
            const [, name, value] = match;
            const numValue = parseFloat(value);
            const readableName = metricNameMap[name] || name.replace(/_/g, " ").replace(/\b\w/g, l => l.toUpperCase());
            metrics.push({
              name: name,
              readableName: readableName,
              value: isNaN(numValue) ? value : numValue,
              displayValue: isNaN(numValue) ? value : numValue.toLocaleString()
            });
          }
        }
        return metrics;
      }
      function renderMetrics(data) {
        const el = document.getElementById("metrics");
        if (typeof data !== "object" || data === null) {
          el.innerHTML = "<pre>" + escapeHtml(String(data)) + "</pre>";
          return;
        }
        const probeText = data.probe_metrics != null ? String(data.probe_metrics) : "";
        const detectorText = data.detector_metrics != null ? String(data.detector_metrics) : "";
        const probeMetrics = parsePrometheusMetrics(probeText);
        const detectorMetrics = parsePrometheusMetrics(detectorText);
        
        // Calculate throughput for detector
        let throughput = null;
        const eventsTotalMetric = detectorMetrics.find(m => m.name === "sentinel_ebpf_detector_events_total");
        const currentTimestamp = data.ts || Date.now() / 1000;
        
        if (eventsTotalMetric && typeof eventsTotalMetric.value === "number") {
          const currentEvents = eventsTotalMetric.value;
          if (previousMetrics.events_total !== null && previousMetrics.timestamp !== null) {
            const timeDelta = currentTimestamp - previousMetrics.timestamp;
            const eventsDelta = currentEvents - previousMetrics.events_total;
            if (timeDelta > 0) {
              throughput = eventsDelta / timeDelta;
            }
          }
          previousMetrics.events_total = currentEvents;
          previousMetrics.timestamp = currentTimestamp;
        }
        
        function renderMetricsTable(metrics, title, extraRows = []) {
          if (metrics.length === 0 && extraRows.length === 0) {
            return `<div class="metrics-block"><h4>${title}</h4><div class="metrics-empty">No metrics available</div></div>`;
          }
          const allRows = [
            ...metrics.map(m => 
              `<tr><td class="metric-name">${escapeHtml(m.readableName)}</td><td class="metric-value">${escapeHtml(String(m.displayValue))}</td></tr>`
            ),
            ...extraRows
          ];
          return `<div class="metrics-block"><h4>${title}</h4><table class="metrics-table"><tbody>${allRows.join("")}</tbody></table></div>`;
        }
        
        const detectorExtraRows = [];
        if (throughput !== null && !isNaN(throughput) && throughput >= 0) {
          const throughputFormatted = throughput >= 1000 
            ? `${(throughput / 1000).toFixed(2)}k events/s`
            : `${throughput.toFixed(2)} events/s`;
          detectorExtraRows.push(
            `<tr><td class="metric-name">Throughput</td><td class="metric-value">${escapeHtml(throughputFormatted)}</td></tr>`
          );
        }
        
        const probeHtml = probeMetrics.length > 0 
          ? renderMetricsTable(probeMetrics, "Probe")
          : `<div class="metrics-block"><h4>Probe</h4><div class="metrics-empty">No metrics available</div></div>`;
        
        const detectorHtml = detectorMetrics.length > 0 || detectorExtraRows.length > 0
          ? renderMetricsTable(detectorMetrics, "Detector", detectorExtraRows)
          : `<div class="metrics-block"><h4>Detector</h4><div class="metrics-empty">No metrics endpoint configured (detector uses gRPC only)</div></div>`;
        
        el.innerHTML = `<div class="metrics-blocks">${probeHtml}${detectorHtml}</div>`;
      }
      let logsSortKey = "ts_unix_nano";
      let logsSortDir = "desc";
      let lastLogsData = null;
      function renderLogs(data) {
        lastLogsData = data;
        const el = document.getElementById("logs");
        if (typeof data !== "object" || data === null) {
          el.innerHTML = "<pre>" + escapeHtml(String(data)) + "</pre>";
          return;
        }
        const message = data.message || "";
        let entries = Array.isArray(data.entries) ? data.entries : [];
        function getCell(entry, key) {
          if (key === "filename") {
            const d = entry.data;
            return Array.isArray(d) && d.length > 0 ? d[0] : (entry.prefix || "—");
          }
          if (key === "ts_unix_nano") {
            return formatTimestampNs(entry.ts_unix_nano);
          }
          const v = entry[key];
          if (v === true || v === false) return v ? "Yes" : "No";
          return v != null ? String(v) : "—";
        }
        function compare(a, b) {
          const va = getCell(a, logsSortKey);
          const vb = getCell(b, logsSortKey);
          if (logsSortKey === "ts_unix_nano") {
            const na = Number(a.ts_unix_nano);
            const nb = Number(b.ts_unix_nano);
            return logsSortDir === "asc" ? na - nb : nb - na;
          }
          if (logsSortKey === "anomaly" || logsSortKey === "score") {
            const na = Number(a[logsSortKey]);
            const nb = Number(b[logsSortKey]);
            if (!isNaN(na) && !isNaN(nb)) return logsSortDir === "asc" ? na - nb : nb - na;
          }
          const c = String(va).localeCompare(String(vb));
          return logsSortDir === "asc" ? c : -c;
        }
        entries = entries.slice().sort(compare);
        const headers = [
          { key: "ts_unix_nano", label: "Time" },
          { key: "event_type", label: "Type" },
          { key: "hostname", label: "Host" },
          { key: "filename", label: "Path" },
          { key: "anomaly", label: "Anomaly" },
          { key: "score", label: "Score" },
          { key: "reason", label: "Reason" },
        ];
        let table = "<div class=\"logs-message\">" + escapeHtml(message || (entries.length ? "Live tail from detector." : "No events yet.")) + "</div>";
        if (entries.length === 0) {
          table += "<p class=\"logs-message\">No entries.</p>";
        } else {
          table += "<div class=\"table-wrap\"><table><thead><tr>";
          headers.forEach(function(h) {
            const sort = h.key === logsSortKey ? logsSortDir : "";
            let arrow = "";
            if (sort === "asc") arrow = " ↑";
            else if (sort === "desc") arrow = " ↓";
            else if (sort === "") arrow = " ↕";
            table += "<th data-sort=\"" + sort + "\" data-key=\"" + escapeHtml(h.key) + "\">" + escapeHtml(h.label) + arrow + "</th>";
          });
          table += "</tr></thead><tbody>";
          entries.forEach(function(entry) {
            table += "<tr>";
            headers.forEach(function(h) {
              let cell = getCell(entry, h.key);
              if (h.key === "anomaly" && (entry.anomaly === true || cell === "Yes")) {
                cell = "<span class=\"badge badge-anomaly\">Yes</span>";
              } else if (h.key === "anomaly" && (entry.anomaly === false || cell === "No")) {
                cell = "<span class=\"badge badge-ok\">No</span>";
              } else {
                cell = escapeHtml(cell);
              }
              table += "<td>" + cell + "</td>";
            });
            table += "</tr>";
          });
          table += "</tbody></table></div>";
        }
        el.innerHTML = table;
        el.querySelectorAll("th[data-key]").forEach(function(th) {
          th.addEventListener("click", function() {
            const key = th.getAttribute("data-key");
            if (key === logsSortKey) logsSortDir = logsSortDir === "asc" ? "desc" : "asc";
            else { logsSortKey = key; logsSortDir = "asc"; }
            if (lastLogsData) renderLogs(lastLogsData);
          });
        });
      }
      function escapeHtml(s) {
        const div = document.createElement("div");
        div.textContent = s;
        return div.innerHTML;
      }
      let chartInstance = null;
      function renderChart(data) {
        const container = document.querySelector(".chart-container");
        if (!container) {
          console.error("Chart container not found");
          return;
        }
        
        // Check if Chart.js is loaded
        if (typeof Chart === "undefined") {
          container.innerHTML = "<div class=\"metrics-empty\">Chart.js library not loaded</div>";
          console.error("Chart.js not loaded");
          return;
        }
        
        // Ensure canvas exists first, before checking data
        let canvas = document.getElementById("chart");
        let wrapper = canvas ? canvas.closest(".chart-wrapper") : null;
        if (!canvas || !wrapper) {
          // Create canvas if it doesn't exist
          wrapper = document.createElement("div");
          wrapper.className = "chart-wrapper";
          canvas = document.createElement("canvas");
          canvas.id = "chart";
          wrapper.appendChild(canvas);
          container.innerHTML = "";
          container.appendChild(wrapper);
        }
        
        if (typeof data !== "object" || data === null || !data.time_buckets) {
          if (chartInstance) {
            chartInstance.destroy();
            chartInstance = null;
          }
          // Don't clear container, just hide/show message
          const existingMsg = container.querySelector(".metrics-empty");
          if (!existingMsg) {
            const msg = document.createElement("div");
            msg.className = "metrics-empty";
            msg.textContent = "No data available";
            wrapper.style.display = "none";
            container.appendChild(msg);
          }
          console.log("No chart data:", data);
          return;
        }
        
        const timeBuckets = data.time_buckets || [];
        if (timeBuckets.length === 0) {
          if (chartInstance) {
            chartInstance.destroy();
            chartInstance = null;
          }
          // Don't clear container, just hide/show message
          const existingMsg = container.querySelector(".metrics-empty");
          if (!existingMsg) {
            const msg = document.createElement("div");
            msg.className = "metrics-empty";
            msg.textContent = "No events in this poll interval";
            wrapper.style.display = "none";
            container.appendChild(msg);
          }
          return;
        }
        
        // Hide any "no data" messages and show chart
        const existingMsg = container.querySelector(".metrics-empty");
        if (existingMsg) {
          existingMsg.remove();
        }
        wrapper.style.display = "block";
        
        // Collect all unique event types across all time buckets
        const eventTypes = new Set();
        timeBuckets.forEach(bucket => {
          Object.keys(bucket.counts || {}).forEach(type => eventTypes.add(type));
        });
        const sortedEventTypes = Array.from(eventTypes).sort();
        
        // Extract time labels (x-axis)
        const timeLabels = timeBuckets.map(bucket => bucket.time);
        
        // Create datasets: one per event type
        const isDark = document.documentElement.getAttribute("data-theme") !== "light";
        const textColor = isDark ? "#e6edf3" : "#1f2328";
        const gridColor = isDark ? "#2d3a4f" : "#d0d7de";
        
        // Color palette for different event types
        const colors = [
          isDark ? "#58a6ff" : "#0969da",  // Blue
          isDark ? "#f85149" : "#cf222e",  // Red
          isDark ? "#3fb950" : "#1a7f37",  // Green
          isDark ? "#d29922" : "#9a6700",  // Yellow/Orange
          isDark ? "#a371f7" : "#8250df",  // Purple
          isDark ? "#79c0ff" : "#0969da",  // Light Blue
          isDark ? "#ff7b72" : "#cf222e",  // Light Red
          isDark ? "#7ee787" : "#1a7f37",  // Light Green
        ];
        
        const datasets = sortedEventTypes.map((eventType, idx) => {
          const color = colors[idx % colors.length];
          return {
            label: eventType,
            data: timeBuckets.map(bucket => bucket.counts[eventType] || 0),
            backgroundColor: color + "80",
            borderColor: color,
            borderWidth: 1
          };
        });
        
        try {
          if (chartInstance) {
            chartInstance.data.labels = timeLabels;
            chartInstance.data.datasets = datasets;
            chartInstance.update();
          } else {
            if (!canvas || !canvas.parentElement) {
              console.error("Canvas not found or not in DOM");
              return;
            }
            chartInstance = new Chart(canvas, {
              type: "bar",
              data: {
                labels: timeLabels,
                datasets: datasets
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                  legend: {
                    display: true,
                    position: "top",
                    labels: {
                      color: textColor,
                      usePointStyle: true
                    }
                  },
                  tooltip: {
                    enabled: true,
                    mode: "index",
                    intersect: false
                  }
                },
                scales: {
                  y: {
                    beginAtZero: true,
                    stacked: false,
                    ticks: {
                      color: textColor,
                      precision: 0
                    },
                    grid: {
                      color: gridColor
                    }
                  },
                  x: {
                    stacked: false,
                    ticks: {
                      color: textColor
                    },
                    grid: {
                      color: gridColor
                    }
                  }
                }
              }
            });
            console.log("Chart created successfully");
          }
        } catch (e) {
          console.error("Error rendering chart:", e);
          container.innerHTML = "<div class=\"metrics-empty\">Error rendering chart: " + escapeHtml(String(e)) + "</div>";
        }
      }

      function renderAnomalies(data) {
        const el = document.getElementById("anomalies");
        if (typeof data !== "object" || data === null) {
          el.innerHTML = "<pre>" + escapeHtml(String(data)) + "</pre>";
          return;
        }
        const entries = Array.isArray(data.entries) ? data.entries : [];
        if (entries.length === 0) {
          el.innerHTML = "<div class=\"metrics-empty\">No anomalies detected</div>";
          return;
        }
        let html = `<div style="max-height: 400px; overflow-y: auto;">`;
        entries.slice().reverse().forEach(entry => {
          const ts = formatTimestampNs(entry.ts_unix_nano);
          const filename = Array.isArray(entry.data) && entry.data.length > 0 ? entry.data[0] : "—";
          html += `<div class="anomaly-item">`;
          html += `<div><strong>${escapeHtml(ts)}</strong> <span class="anomaly-score">Score: ${escapeHtml(String(entry.score || 0))}</span></div>`;
          html += `<div style="color: var(--text-muted); font-size: 0.75rem; margin-top: 4px;">${escapeHtml(filename)}</div>`;
          html += `<div style="color: var(--text-muted); font-size: 0.75rem; margin-top: 2px;">${escapeHtml(entry.reason || "")}</div>`;
          html += `</div>`;
        });
        html += `</div>`;
        el.innerHTML = html;
      }

      async function refresh() {
        try {
          const status = await fetchJson("/api/status");
          renderStatus(status);
        } catch (e) {
          const statusEl = document.getElementById("status");
          if (statusEl) {
            statusEl.innerHTML = "<div class=\"metrics-empty\">Error loading status: " + escapeHtml(String(e)) + "</div>";
          }
        }
        try {
          const metrics = await fetchJson("/api/metrics");
          renderMetrics(metrics);
        } catch (e) {
          const metricsEl = document.getElementById("metrics");
          if (metricsEl) {
            metricsEl.innerHTML = "<div class=\"metrics-empty\">Error loading metrics: " + escapeHtml(String(e)) + "</div>";
          }
        }
        try {
          const chart = await fetchJson("/api/calls_chart");
          renderChart(chart);
        } catch (e) {
          const container = document.querySelector(".chart-container");
          if (container) {
            container.innerHTML = "<div class=\"metrics-empty\">Error loading chart: " + escapeHtml(String(e)) + "</div>";
          }
        }
        try {
          const anomalies = await fetchJson("/api/anomalies?limit=100");
          renderAnomalies(anomalies);
        } catch (e) {
          const anomaliesEl = document.getElementById("anomalies");
          if (anomaliesEl) {
            anomaliesEl.innerHTML = "<div class=\"metrics-empty\">Error loading anomalies: " + escapeHtml(String(e)) + "</div>";
          }
        }
        try {
          const logs = await fetchJson("/api/logs?limit=" + logLimit);
          renderLogs(logs);
        } catch (e) {
          const logsEl = document.getElementById("logs");
          if (logsEl) {
            logsEl.innerHTML = "<div class=\"metrics-empty\">Error loading logs: " + escapeHtml(String(e)) + "</div>";
          }
        }
      }
      refresh();
      setInterval(refresh, pollSeconds * 1000);
    </script>
  </body>
</html>
